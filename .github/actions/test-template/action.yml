# Copyright (c) 2025, NVIDIA CORPORATION. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: "Test Template"
description: "Template for running NeMo tests in a containerized environment"

inputs:
  timeout:
    description: "Max runtime of test in minutes"
    required: false
    default: "10"
  script:
    description: "Test script to execute"
    required: true
  is-optional:
    description: "Failure will cancel all other tests if set to true"
    required: false
    default: "false"
  is_unit_test:
    description: "Upload coverage as unit test"
    required: false
    default: "false"
  azure-client-id:
    description: "Azure Client ID"
    required: true
  azure-tenant-id:
    description: "Azure Tenant ID"
    required: true
  azure-subscription-id:
    description: "Azure Subscription ID"
    required: true
  has-azure-credentials:
    description: "Has Azure credentials"
    required: false
    default: "false"
  PAT:
    description: "GitHub Personal Access Token"
    required: true

runs:
  using: "composite"
  steps:
    # - name: Install curl, sudo
    #   shell: bash
    #   run: |
    #     apt-get update
    #     apt-get install -y curl sudo uuid-runtime systemd

    # - name: Install Docker with custom script
    #   shell: bash
    #   run: |
    #     # Download and modify the Docker install script
    #     curl -fsSL https://get.docker.com -o get-docker.sh

    #     # Install only CLI components (remove daemon installation)
    #     export DEBIAN_FRONTEND=noninteractive
    #     apt-get update -qq
    #     apt-get install -y ca-certificates curl gnupg lsb-release

    #     install -m 0755 -d /etc/apt/keyrings
    #     curl -fsSL "https://download.docker.com/linux/ubuntu/gpg" -o /etc/apt/keyrings/docker.asc
    #     chmod a+r /etc/apt/keyrings/docker.asc

    #     echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu jammy stable" > /etc/apt/sources.list.d/docker.list

    #     apt-get update -qq
    #     # Install CLI only, skip daemon and user management
    #     apt-get install -y docker-ce-cli docker-buildx-plugin docker-compose-plugin

    #     docker --version

    # - name: Install Azure CLI
    #   if: ${{ inputs.has-azure-credentials == 'true' }}
    #   shell: bash
    #   run: |
    #     echo "::group::Install Azure CLI"
    #     # Create systemd override for proper dependencies
    #     curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
    #     echo "::endgroup::"

    # - name: Azure Login
    #   if: ${{ inputs.has-azure-credentials == 'true' }}
    #   uses: azure/login@v2
    #   with:
    #     client-id: ${{ inputs.azure-client-id }}
    #     tenant-id: ${{ inputs.azure-tenant-id }}
    #     subscription-id: ${{ inputs.azure-subscription-id }}

    # - name: Azure ACR Login
    #   if: ${{ inputs.has-azure-credentials == 'true' }}
    #   shell: bash
    #   run: |
    #     az acr login --name nemoci

    # - name: Configure local file cache
    #   shell: bash
    #   if: ${{ inputs.has-azure-credentials == 'true' && inputs.is_unit_test == 'false' }}
    #   env:
    #     MNT_PATH: ${{ steps.azure-fileshare.outputs.MNT_PATH }}
    #   run: |
    #     echo "::group::Configure local artifact cache"

    #     set -x -e -u -o pipefail

    #     sudo apt update
    #     sudo apt install -y cachefilesd

    #     # Create systemd override for proper dependencies
    #     sudo mkdir -p /etc/systemd/system/cachefilesd.service.d
    #     printf "[Unit]\nAfter=network.target local-fs.target\nWants=local-fs.target\n\n[Service]\nRestart=on-failure\nRestartSec=2\n" | sudo tee /etc/systemd/system/cachefilesd.service.d/override.conf > /dev/null
    #     sudo systemctl daemon-reload

    #     # Enable cachefilesd in config file
    #     sudo sed -i 's/^#RUN=yes/RUN=yes/' /etc/default/cachefilesd
    #     sudo cat /etc/default/cachefilesd

    #     # Enable and restart the service
    #     sudo systemctl enable cachefilesd
    #     sudo systemctl restart cachefilesd
    #     sudo systemctl status cachefilesd
    #     echo "::endgroup::"

    # - name: Azure Fileshare
    #   if: ${{ inputs.has-azure-credentials == 'true' && inputs.is_unit_test == 'false' }}
    #   shell: bash
    #   id: azure-fileshare
    #   run: |
    #     echo "::group::Mount SMB drive"
    #     sudo apt update
    #     sudo apt install -y cifs-utils

    #     RESOURCE_GROUP_NAME="azure-gpu-vm-runner_group"
    #     STORAGE_ACCOUNT_NAME="nemocistorageaccount2"
    #     FILE_SHARE_NAME="fileshare"

    #     MNT_ROOT="/media"
    #     MNT_PATH="$MNT_ROOT/$STORAGE_ACCOUNT_NAME/$FILE_SHARE_NAME"

    #     echo "MNT_PATH=$MNT_PATH" | tee -a "$GITHUB_OUTPUT"

    #     sudo mkdir -p $MNT_PATH

    #     # Create a folder to store the credentials for this storage account and
    #     # any other that you might set up.
    #     CREDENTIAL_ROOT="/etc/smbcredentials"
    #     sudo mkdir -p "/etc/smbcredentials"

    #     # Get the storage account key for the indicated storage account.
    #     # You must be logged in with az login and your user identity must have
    #     # permissions to list the storage account keys for this command to work.
    #     STORAGE_ACCOUNT_KEY=$(az storage account keys list \
    #         --resource-group $RESOURCE_GROUP_NAME \
    #         --account-name $STORAGE_ACCOUNT_NAME \
    #         --query "[0].value" --output tsv | tr -d '"')

    #     # Create the credential file for this individual storage account
    #     SMB_CREDENTIAL_FILE="$CREDENTIAL_ROOT/$STORAGE_ACCOUNT_NAME.cred"
    #     if [ ! -f $SMB_CREDENTIAL_FILE ]; then
    #         echo "username=$STORAGE_ACCOUNT_NAME" | sudo tee $SMB_CREDENTIAL_FILE > /dev/null
    #         echo "password=$STORAGE_ACCOUNT_KEY" | sudo tee -a $SMB_CREDENTIAL_FILE > /dev/null
    #     else
    #         echo "The credential file $SMB_CREDENTIAL_FILE already exists, and was not modified."
    #     fi

    #     # Change permissions on the credential file so only root can read or modify the password file.
    #     sudo chmod 600 $SMB_CREDENTIAL_FILE

    #     # This command assumes you have logged in with az login
    #     HTTP_ENDPOINT=$(az storage account show --resource-group $RESOURCE_GROUP_NAME --name $STORAGE_ACCOUNT_NAME --query "primaryEndpoints.file" --output tsv | tr -d '"')
    #     SMB_PATH=$(echo $HTTP_ENDPOINT | cut -c7-${#HTTP_ENDPOINT})$FILE_SHARE_NAME

    #     STORAGE_ACCOUNT_KEY=$(az storage account keys list --resource-group $RESOURCE_GROUP_NAME --account-name $STORAGE_ACCOUNT_NAME --query "[0].value" --output tsv | tr -d '"')

    #     sudo mount -t cifs $SMB_PATH $MNT_PATH -o credentials=$SMB_CREDENTIAL_FILE,serverino,nosharesock,actimeo=30,mfsymlinks,fsc,cache=strict

    #     ls -al $MNT_PATH/TestData
    #     echo "::endgroup::"

    - name: Checkout repository
      uses: actions/checkout@v2
      with:
        path: ${{ github.workspace }}/Megatron-Bridge

    - name: Cache uv
      uses: actions/cache@v4
      id: cache
      with:
        path: cache-mount
        key: ${{ runner.os }}-uv-${{ hashFiles('**/uv.lock') }}

    - name: Restore Docker cache mounts
      uses: reproducible-containers/buildkit-cache-dance@5b81f4d29dc8397a7d341dba3aeecc7ec54d6361
      with:
        cache-dir: cache-mount
        dockerfile: docker/Dockerfile.ci
        skip-extraction: ${{ steps.cache.outputs.cache-hit }}

    - name: Build container
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.PAT }}
      run: |
        echo "::group::Build test container"
        docker build -f docker/Dockerfile.ci  --secret id=GH_TOKEN -t megatron-bridge .
        echo "::endgroup::"

    - name: Start container
      shell: bash
      env:
        MNT_PATH: ${{ steps.azure-fileshare.outputs.MNT_PATH }}
        MOUNT_FS: ${{ inputs.has-azure-credentials == 'true' && inputs.is_unit_test == 'false' }}
      run: |
        echo "::group::Start test container"
        if [[ "$MOUNT_FS" == "true" ]]; then
          VOLUME_ARGS="--volume /mnt/datadrive/TestData:/home/TestData"
        else
          VOLUME_ARGS=""
        fi

        cmd=$(cat <<RUN_TEST_EOF
        #!/bin/bash
        docker container rm -f nemo_container_${{ github.run_id }} || true
        docker run \
          --rm \
          -d \
          --name nemo_container_${{ github.run_id }} \
          --runtime=nvidia --gpus all \
          --shm-size=64g \
          --env TRANSFORMERS_OFFLINE=0 \
          --env HYDRA_FULL_ERROR=1 \
          --env HF_HOME=/home/TestData/HF_HOME \
          --env NEMO_HOME=/home/TestData/nemo_home \
          --env RUN_ID=${{ github.run_id }} \
          --workdir /workspace \
          --volume ${{ github.workspace }}/Megatron-Bridge:/workspace \
          $VOLUME_ARGS \
          megatron-bridge \
          bash -c "sleep $(( ${{ inputs.timeout }} * 60 + 60 ))"
        RUN_TEST_EOF
        )

        echo "$cmd" | tee "retry_job.sh"
        bash retry_job.sh
        echo "::endgroup::"

    - name: Create run-script
      id: create
      shell: bash
      run: |
        echo "::group::Create run-script"
        COVERAGE_PREFIX=$([[ "${{ inputs.is_unit_test }}" == "true" ]] && echo "unit-test" || echo "e2e")
        echo "coverage-prefix=$COVERAGE_PREFIX" | tee -a "$GITHUB_OUTPUT"

        cmd=$(cat <<'RUN_TEST_EOF'
        #!/bin/bash

        docker exec -t nemo_container_${{ github.run_id }} bash -c '
          set -e
          export GH_TOKEN=${{ inputs.PAT }}
          bash tests/${{ inputs.is_unit_test == 'true' && 'unit_tests' || 'functional_tests' }}/${{ inputs.script }}.sh
        '

        RUN_TEST_EOF
        )

        echo "timeout_in_seconds=$(( ${{ inputs.timeout }} * 60 ))" | tee -a "$GITHUB_OUTPUT"
        echo "$cmd" | tee "job.sh"
        echo "::endgroup::"

    - name: Run main script
      uses: nick-fields/retry@v3
      id: run-main-script
      with:
        timeout_seconds: ${{ steps.create.outputs.timeout_in_seconds }}
        max_attempts: 3
        shell: bash
        retry_on: timeout
        command: /bin/bash job.sh
        on_retry_command: /bin/bash retry_job.sh

    - name: Check result
      id: check
      shell: bash
      run: |
        echo "::group::Check result"

        docker exec nemo_container_${{ github.run_id }} /opt/venv/bin/coverage combine || true
        docker exec nemo_container_${{ github.run_id }} /opt/venv/bin/coverage xml
        docker cp nemo_container_${{ github.run_id }}:/workspace/.coverage .coverage
        docker cp nemo_container_${{ github.run_id }}:/workspace/coverage.xml coverage.xml

        coverage_report=coverage-${{ steps.create.outputs.coverage-prefix }}-${{ github.run_id }}-$(uuidgen)
        echo "coverage_report=$coverage_report" >> "$GITHUB_OUTPUT"

        EXIT_CODE=${{ steps.run-main-script.outputs.exit_code }}
        IS_SUCCESS=$([[ "$EXIT_CODE" -eq 0 ]] && echo "true" || echo "false")

        if [[ "$IS_SUCCESS" == "false" && "${{ inputs.is-optional }}" == "true" ]]; then
          echo "::warning:: Test failed, but displayed as successful because it is marked as optional."
          IS_SUCCESS=true
        fi

        if [[ "$IS_SUCCESS" == "false" ]]; then
          echo Test did not finish successfully.
          exit 1
        else
          docker exec -t nemo_container_${{ github.run_id }} /opt/venv/bin/coverage report -i
        fi

        exit $EXIT_CODE
        echo "::endgroup::"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      if: ${{ steps.check.outputs.coverage_report != 'none' }}
      with:
        name: ${{ steps.check.outputs.coverage_report }}
        path: |
          coverage.xml
          .coverage
        include-hidden-files: true
    
    - name: Container shutdown
      if: always()
      shell: bash
      run: |
        docker container rm -f nemo_container_${{ github.run_id }} || true
